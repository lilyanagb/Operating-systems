85.
0x55 - ще го пропускаме
0x7D - ще проверяваме дали предхожда и го скипваме
C XOR ще върнем стария вариант 

8421
0 1 2 3 4 5 6 7 8 9 A B C D E F 
=> 2 = 0010
0111 0101 = 0x75

- 1 тръба
- child
- execlp("cat") in child
- output of execlp p[1]
- parent
- четем от тръбата, проверяваме и записваме в другия файл

int pf[2];
if (pipe(pf) == -1)...
pid_t pid = fork();
if(pid == 0){
 close(pf[0]);
 dup2(pf[1], 1); -> всичко което е ориентираме към аутпута го вкарай в тръбата
 if(execlp(..., argv[1]) == -1) ...
}

close(pf[1]);
int fd = open(argv[2]);

while( read(pf[0], &c,1 ) > 0){
 if ( c == 0x7D){
	if( read(pf[0]..) == -1){
		
	}
	
	c = c ^ 0x20;

	if ( c == '0x00' || c == '0xFF' || c == '0x55' || c == '0x7D'){
		write(fd, &c, 1)
	}else
	{
		errx();
	}
} else if ( c == 0x55){
	continue;
}else {
	write();
}

71.
int scl = open();
int sdl = open();
int fd = open (.., O_CREAT);

uint8_t level;
uint16_t buf;
uint16_t counter = 0;

while( read(scl, &level,..) != 0){
	for( int i=7; i>= 0;i--){
		if (level & (1<<i)) != 0){
			lseek(sdl, (counter)*sizeof(uint16_t), SEEK_SET);
			read(sdl, &buf,..);
		}
		if( write(fd, &buf,..)
	counter++;
	}
}

0111 1111
0000 0001
num & (1 << i)
