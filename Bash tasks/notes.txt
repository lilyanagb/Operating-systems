grep [OPTION...] PATTERNS [FILE...]
grep [OPTION...] -e PATTERNS -e PATTERNS ... [FILE...]
grep [OPTION...] -f PATTERN_FILE ... [FILE...]
 -i, --ignore-case
 -v, --invert-match
 -o, --only-matching
 -r, recursively
 -c, --count
? The preceding item is optional and matched at most once.
* The preceding item will be matched zero or more times.
+ The preceding item will be matched one or more times.
{n} The preceding item is matched exactly n times.
{n,} The preceding item is matched n or more times.
{,m} The preceding item is matched at most m times.
{n,m} The preceding item is matched at least n times, but not more than m times.

grep -n ' '

grep -E = egrep (можем да ползваме ? + | etc)

grep -A 2 <string> <file> - 2 lines after the string
grep -B 3

grep -o "[[:alpha:]]\+ [[:alpha:]]\+"
grep -o "\"[[:print:]]\+\"[[:print:]]\+$" 
grep "^[[:digit:]]\+,$(echo $line | cut -d ',' -f2-)$" -> изкарвам първата колона, която е число и грепвам по останалото в реда да видя дали матчват (така после мога да сортирам по номера)
grep -q "^[-]\{0,1\}[[:digit:]]\+$"  -> всички цели числа + и - 
grep -o '.'
grep -qF - F tretira kato ne regulyaren,t.e . * sa si standartni simvoli
egrep -qn  връща изходен код 0, ако има намерено съвпадение, и 1 в противен случай, като допълнително извежда номера на реда, на който е намереното съвпадение, на стандартния изход.

~ - home directory of current user
/ - file system
~pesho - pesho`s home directory

echo -e -  allows you to use escape characters

wc - number of lines, words, and characters
wc -l
wc -w
wc -c
The uppercase (-L) flag is used in this section to output the number of characters of the file’s longest line.

find -printf " ":
%s File's size in bytes.
%f File's name.
%p Full path name
%n Number of hard links to file. (които имат повече от едно име също означава)
%t File's last modification time in the format returned by the C `ctime' function.
%T@
%n Number of hard links to file.
%p File's name.
%P File's name with the name of the starting-point under which it was found removed. (релатив път)
%s File's size in bytes.
%t File's last modification time in the format returned by the C `ctime' function.
%i - inode
%C@ - creation timestamp
%d - дава дълбочината на файла

-type f d
-type l - симлинкове
find -L $1 -type l - счупени симлинкове
-name
-and -or
-not (-name ..)
-name "bld" -prune -prevent find from going into a directory that matches some tests.
ako imeto ima regex:
-regex '.*/s[0-9]+'
-print
-maxdepth -mindepth 
-perm 0020
-perm -g=w (u,g,o)
-empty
-P - Never follow symbolic links.
-L - Follow symbolic links.
-amin +-n - File was last accessed less than, more than or exactly n minutes ago.
-cmin n - File's status was last changed less than, more than or exactly n minutes ago.
-executable - Matches files which are executable and directories which are searchable (in a file name resolution sense) by the current user.
-readable
-writable
-size 42c
-gid n - File's numeric group ID is less than, more than or exactly n.
-group gname - File belongs to group gname (numeric group ID allowed).
-inum n - File has inode number smaller than, greater than or exactly n. 
-mmin n -File's data was last modified less than, more than or exactly n minutes ago.
-newer reference - Time of the last data modification of the current file is more recent than that of the last data modification of the reference file.

head -n -7 - последни 7
tail -n -3 - първи 3
head -c 67 
tail -n +2 - bez header-a 

find .... -exec <command> {} \;

sort -n -r 
sort -d
sort -n -t <separator> -k3 <filename>
sort -nr -t '.' -k123  !!!!!! ne go razbiram zad28

cut -c 
cut -d -f
5- ot 5 natatyk
-5 vsichko do 5
5-10 mejdu 5 i 10

chmod u+x
chmod go+rw

uniq -c

tr [:space:] '\n'
tr [:upper:] [:lower:]

default 777 -> 111 111 111
mask 0022   -> 000 010 010
!mask       -> 111 101 101
default & (!mask) : 111 101 101 -> 755

^([^:]+:){3}

#!/bin/bash

if [ $# -eq 1 ] && ( echo $1 | grep -q "^[[:digit:]]\+$" ) && [ "$(whoami)" = "root" ];then

if [ ! -f $1 ]; then
echo "Wrong argument passed!"
exit 1
fi

while read line; do
...
done < <(echo "$directories")

for file in "${@:3}"; do
..
done

done < <(cat /etc/passwd | cut -d ':' -f1,6 | tr ':' ' ') | sort -nr -t ' ' -k3 | cut -d ' ' -f1,2 | head -1


if [ ! -d $home ] || sudo -u $user [ ! -w $home ];then
            echo "$user"
        fi

if [ $(echo "$info" | cut -d ' ' -f3) -gt $(( total * 2 / $(echo "$info" | cut -d ' ' -f2))) ]; then

if [ ! -d $home ] || [ $(stat $home -c "%U") != $user ] || [ ! -w $home ];then
• имат зададена несъществуваща home директория;
• не са собственици на home директорията си;
• собственика на директорията не може да пише в нея


sudo -u $user: Това изпълнява командата, която следва, като променливата $user се използва за превключване на потребителя на $user. Това означава, че командата [ ! -w $home ] се изпълнява от името на потребителя $user, а не от потребителя, който изпълнява скрипта

ps aux
ps -e -o user=,pid=,rss= --sort=-rss
ps --user $username -o pid=,rss= --sort=-rss
kill -KILL $pid
ps --user "$user" -o pid= | xargs -I {} kill -s KILL {} - убиваме всички процеси

-eq
-ne
-gt
-lt
-ge
-le

mv <old> <new>
mkdir -p -> recursively

awk '{print NR".", $0}' - номериране на редовете 
awk 'BEGIN{total=0}{total=total+$1}END{print (total/NR)}'
awk -v min=$2 '{if(min <= $2){print $0}}'
ps --user "s62599" -o rss= | awk 'BEGIN{total=0; max=0}{total+=$1; if(max < $1) max=$1}END{print total, NR, max}'

input=$(while read line
do
    if ( echo "$line" | grep -q "^[-]\{0,1\}[[:digit:]]\+$" );then
        echo "$line"
    fi
done) -> четем от стдина 

awk ..
sed 's/;/\t/g' разделено с таб
sed 's/[[:digit:]]\+|\([[:alpha:]]\+\)|[[:alpha:]]\+|\([[:alpha:]]\+\)/\1:\2/g'
sed -i
sed -E? - allows you to use features like + for one or more occurrences, ? for zero or one occurrence, {} for specifying a range of occurrences, and capturing groups with parentheses.

sed -n s///p
/p е опцията на sed, която указва да се изведе резултата от замяната.
-n е опцията на sed, която указва да бъде изключено автоматичното извеждане на редовете.

sed 's/^[[:blank:]]*//' | tr -s '[:blank:]' ' '
| tr -s ' ' | sed "s/ //" 
sed "s/-//g" | grep -o "." 
sed -r - extended regular expr
xargs -I {} stat {} -c "%N"
grep "$friend" | xargs -I {} cat {} | wc -l

real_name="$(echo "$file" | sed -E "s/"$SRC"\///")"
mkdir -p "$DST/"$(dirname "$real_name")"
mv "$file" "$DST"/"$real_name"

kakwa beshe razlikata mejdu find | while.. i while done<(find)

tar xzf "$filename" -C "$folder" 

    read -p "$1 already exists, Do you want to replace it? [y/n] " choice
    
    while [ "$choice" != "y" -a "$choice" != "n" ]; do
        read -p "Please, enter \"y\" or \"n\": " choice
    done
    
    if [ "$choice" = "n" ]; then
        exit 1
    else 
        if ! rm "$1"; then
            echo "There was a problem removing $1" >&2
            exit 2
        fi
    fi

<<< "$no_space_file - podawame sudurjanie na promenliva (Primerno kym grep)

//добавя коментар (символът #) в началото на реда, който се намира на позиция ${line} във файла $1
while read line; do
    sed -i "${line}s/^/# /" "$1" 
    sed -i "${line}s/$/ # edited at $(date) by $(whoami)/" "$1"
    sed -i "${line}s/$/\n$2 = $3 # added at $(date) by $(whoami)/g" "$1" 
done <<< "$(egrep -n "^[[:space:]]*$2[[:space:]]*=" "$1" | sed -E "s/^([0-9]+):(.*)$/\1/g")"

mktemp
stat -c "%X" се използва за извличане на времето на последна промяна (mtime) на файл
$0 -> tekushtiya script
stat -c "%Y" "$file"
if (( $(echo $(stat -c "%X" "$0") > $(stat -c "%Y" "$file")" | bc -l) )); then 
		continue
	fi
	
bc -l
touch "$0" -> актуализиране на времето на последно промяна на текущия скрипт