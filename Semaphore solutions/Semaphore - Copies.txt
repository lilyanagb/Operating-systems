102. 2017-SE-02
Първо забелязаме, че семафорът m се ползва само от P в ролята на mutex. В неговата опашка
може да има само копия на P и само едно работещо копие може да намалява/увеличава брояча
синхронизирано с блокирането/освобождаването на семафора e.
Увеличаването на cnt става преди критичната секция на P, а намалянето след нея. Ако
не вървят никакви копия на Q, лесно се убеждаваме, че могат да се изпълняват произволен
брой критични секции на P, като броячът съвпада с броя на паралелно изпълняваните критични
секции. Така отговорът на въпрос (б) е ДА.
Заемането на семафора e в P става точно когато cnt променя стойността си от 0 в 1. Освобождаването става точно когато cnt променя стойността си от 1 в 0.
Тъй като при инициализацията броячът на e е 1, а употребата му и в двата вида процеси
започва със заемане и завършва с освобождаване, само едно копие от двата типа ще може да
премине e.wait(). Разглеждаме два случая:
(A) Процесът Q преминава. Тогава ще се изпълни критичната му секция, но само от това копие. Останалите копия на Q ще бъдат приспани от първата си инструкция. Следователно
отговорът на въпрос (в) е НЕ.
Ако версия на P пробва e.wait(), тя също ще бъде приспана. Това ще стане точно когато
cnt променя стойността си от 0 в 1, тоест не се изпълняват критични секции на P. В момента
на приспиване и мутекса m е блокиран. Това обстоятелство ще блокира всички опити на други
копия на P да преминат m. В този случай в опашката на семафора e има точно едно копие на P.
(B) Процесът P преминава. Ще започне изпълнение на неговата критична секция и евентуално на други копия на P, докато cnt>0. През този период всички копия на Q ще бъдат приспани
от първата си инструкция. Когато cnt намалее до 0, никое копие не изпълнява критична секция.
От двата разгледани случая следва, че в един момент могат да се изпълняват няколко
критични секции на P или една критична секция на Q. Следователно отговорът на въпрос (а) е
НЕ.
В описаната схема няма условия за deadlock. Q не може да инициира deadlock, тъй като
ползва само един ресурс. P също не може поради реда на заемане на ресурсите (първо заема
семафора m, после e).
В описаната схема има условия за гладуване (starvation) на процес Q. Нека критичната секция на P се изпълнява бавно и Q започва работа след P. Ще започне изпълнение на критична
секция на P и ако постоянно започват работа нови копия, броячът cnt може да остане положителен неограничено време. Така Q ще бъде приспан неограничено дълго.

103. 2017-SE-03
Semaphore s1
s1.init(1)

process P
p_1
s.wait()
p_2
s.signal()
p_3

104. 2017-SE-08
Semaphore s1,s2
s1.init(1)
s2.init(0)

process P 	process Q
s1.wait()	s2.wait()
p_1 		q_1
p_2 		q_2
s2.signal()	s1.signal()

105. 2018-SE-03
Semaphore s1,s2,s3
s1.init(0)
s2.init(0)
s3.init(1)

process P 	process Q
s3.wait()
p_1 		q_1
s1.signal()	s1.wait()
p_2 		q_2
s2.wait()	s2.signal()
p_3 		q_3
s3.signal()

106. 2020-CS-01
Semaphore s1,s2,s3
s1.init(1)
s2.init(0)
s3.init(0)

process P 	process Q 	process R
s1.wait()	s2.wait()	s3.wait()
p_1 		q_1 		r_1
p_2 		q_2 		r_2
s2.signal()	s3.signal()	s1.signal()

2020-SE-01* Осигурете чрез семафори синхронизация на P и Q така, че поне една инструкция p1 да се изпълни преди всички q2, и поне една инструкция q1 да се изпълни преди всички p2.

Semaphore s1,s2
s1.init(0)
s2.init(0)

process P 	process Q
s3.wait()
p_1 		q_1
s1.signal()	s2.signal()
s2.wait()	s1.wait()
s2.signal()	s1.signal() -> ще събуди всички приспани други копия и ще осигури завършването им
p_2 		q_2
p_3 		q_3

107. 2020-SE-02
Semaphore s1,s2
s1.init(1)
s2.init(0)

process P 	process Q 	process R 	process W
s1.wait()	s1.wait()	s2.wait()	s2.wait()
p_1 		q_1 		r_1 		w_1
p_2 		q_2 		r_2 		w_2
s2.signal()	s2.signal()	s1.signal()	s1.signal()

108.* 2021-SE-01
Semaphore s1,s2
s1.init(0)
s2.init(0)

process P 	process Q 	process R
				s1.wait()
				s2.wait()
				s1.signal()
				s2.signal()	
p_1 		q_1 		r_1
p_2 		q_2 		r_2
s1.signal()	s2.signal()


С променена подредба:
111. 2023-CS-01
s.init(1)
t.init(0)
int cnt = 0

process P	process Q
cnt += 1	t.wait()
if cnt == 1: 
   s.wait()
else  
   s.signal()
p_1		q_1
p_2		q_2
t.signal()


112. 2023-SE-01
s.init(1)
t.init(0)
z.init(0)
int cnt = 0

process P	process Q	process R
s.wait()	t.wait()	z.wait()
p_1		q_1		r_1
p_2		q_2		r_2
cnt += 1	s.signal()	s.signal()
if cnt == 1:
   t.signal()
else
   cnt = 0
   z.signal()