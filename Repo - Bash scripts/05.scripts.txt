cd /srv/fmi-os/exercises/05.scripts
astero.openfmi.net
! PATH="/home/human:${PATH}", ако искаме да пускаме foo.sh, а не ./foo.sh или целия път
! alias 'cgrep=grep --color'
! vim ~/.bashrc - можем да си добавим alias
! :! <command> % (%- текущ файл) - да пускаме команди директно от vim
! sed '5!s///g' - направи промяна на всеки ред освен на 5-тия
! [[ "string" =~ pattern ]]

05-a-2000: Сменете вашия prompt с нещо по желание. После върнете оригиналния обратно.

Ans:  PS1=s62599
	PS1=$(whoami)@$(hostname):\w\$ 

05-a-2100: Редактирайте вашия .bash_profile файл, за да ви поздравява (или да изпълнява някаква команда по ваш избор) всеки път, когато влезете в системата.

Ans:  vim ~/.profile
	echo "Hello, $(whoami)!" (в края на файла)

05-a-2200: Направете си ваш псевдоним (alias) на полезна команда.

Ans: alias 'cgrep=grep --color'

05-b-2000: Да се напише shell скрипт, който приканва потребителя да въведе низ (име) и изпечатва "Hello, низ".

Ans: 
read -p "Enter your name: " name
echo "Hello, ${name}"

05-b-2800: Да се напише shell скрипт, който приема точно един параметър и проверява дали подаденият му параметър се състои само от букви и цифри.

Ans:
if echo "${1}" | grep -q '[^a-zA-Z0-9]'; then
	echo "Not alphanumeric"
else
	echo "OK, alphanumeric"

05-b-3100: Да се напише shell скрипт, който приканва потребителя да въведе низ - потребителско име на потребител от системата - след което извежда на стандартния изход колко активни сесии има потребителят в момента.

Ans:
read -p "Your username: " name
echo $(who | grep "${name}" | wc -l)

05-b-3200: Да се напише shell скрипт, който приканва потребителя да въведе пълното име на директория и извежда на стандартния изход подходящо съобщение за броя на всички файлове и всички директории в нея.

Ans:
read -p "Enter your full directory: " dir
files=${find "${dir}" -mindepth 1 -type f 2>/dev/null | wc -l)
directory=${find "${dir}" -mindepth 1 -type d 2>/dev/null | wc -l)
echo "Directories are ${directory} and files are ${files}"

05-b-3300: Да се напише shell скрипт, който чете от стандартния вход имената на 3 файла, обединява редовете на първите два (man paste), подрежда ги по азбучен ред и резултата записва в третия файл.

Ans: 
if [ $# -ne 3 ] || [ ! -f $1 ] || [ ! -f $2 ] || [ ! -f $3 ]; then
    echo "Wrong arguments passed"
    exit 1
fi

paste $1 $2 | sort -d >> $3

05-b-3400: Да се напише shell скрипт, който чете от стандартния вход име на файл и символен низ, проверява дали низа се съдържа във файла и извежда на стандартния изход кода на завършване на командата с която сте проверили наличието на низа.
NB! Символният низ може да съдържа интервал (' ') в себе си.

Ans:
if [ $# -ne 2 ] || [ ! -f $1 ];then
    echo "Wrong arguments passed!"
    exit 1
fi

cat $1 | grep -q "$2"
echo $?

! grep -o - only-matching и принти, ако намери вярното
! $? - държи exit status-а на последната изпълнена команда
  0 - success
  1-255 - fail

05-b-4200: Имате компилируем (a.k.a няма синтактични грешки) source file на езика C. Напишете shell script, който да покaзва колко е дълбоко най-дълбокото nest-ване (влагане).
Примерен .c файл:

#include <stdio.h>

int main(int argc, char *argv[]) {

  if (argc == 1) {
		printf("There is only 1 argument");
	} else {
		printf("There are more than 1 arguments");
	}

	return 0;
}
Тук влагането е 2, понеже имаме main блок, а вътре в него if блок.

Примерно извикване на скрипта:

./count_nesting sum_c_code.c

Изход:
The deepest nesting is 2 levels

Ans:
c_file=$1
count=0

cat "${c_file}" | grep -o "[{}]" |
        while read symbol; do
                if [[ "${symbol}" == '{' ]]; then
                        count=$(( count + 1 ))
                        echo "${count}"
                else
                        count=$(( count - 1 ))
                        echo "${count}"
                fi
        done | sort -r | head -n 1

Ans:
temp_file="$(mktemp)"
cat "${1} | tr -d -c '{}' > "${temp_file}"
while grep -q '{}' "${temp_file}"; do
	sed -i 's/{}//g' "${temp_file}"
	echo "level"
done | wc -l

rm "${temp_file}"

! read -d -можем да дадем delimeter
! tr -s - прави ги до едно срещане (за спейс примерно) == sed 's/[[:space:]]\+/ /g'
! tr -dc '{}' - изтрива всичко различно от {}

05-b-4301: Напишете shell script, който автоматично да попълва файла указател от предната задача по подадени аргументи: име на файла указател, пълно име на човека (това, което очакваме да е в /etc/passwd) и избран за него nickname.
Файлът указател нека да е във формат:
<nickname, който лесно да запомните> <username в os-server>
// може да сложите и друг delimiter вместо интервал

Примерно извикване:
./pupulate_address_book myAddressBook "Ben Dover" uncleBen

Добавя към myAddressBook entry-то:
uncleBen <username на Ben Dover в os-server>

***Бонус: Ако има няколко съвпадения за въведеното име (напр. има 10 човека Ivan Petrov в /etc/passwd), всички те да се показват на потребителя, заедно с пореден номер >=1,
след което той да може да въведе някой от номерата (или 0 ако не си хареса никого), и само избраният да бъде добавен към указателя.

Аns: 
if [ $# -ne 3 ] || !(grep -q "$2" /etc/passwd ); then
    echo "Wrong arguments passed"
    exit 1
fi

if [ $(grep "$2" /etc/passwd | wc -l ) -gt 1 ]; then
    output=$(grep "$2" /etc/passwd | awk 'BEGIN{counter=1}{print counter,$0 counter++}')
    echo "$output"
    read
    reply=$REPLY
    if [ $reply -eq 0 ]; then
       exit 0
    fi

    user=$(echo "$output" | awk -v num=$reply '{if(num == $1){print $0}}' | cut -d ':' -f1 | cut -d ' ' -f2)
    echo "$3 $user" >> $1
else 
    username=$(grep "$2" /etc/passwd | cut -d ':' -f1 | cut -d ' ' -f2)
    echo "$3 $username" >> $1
fi

exit 0

! read -> $REPLY очаква въвеждане от потребителя, чете ред

05-b-4400: Напишете shell script, който да приема параметър име на директория, от която взимаме файлове, и опционално експлицитно име на директория, в която ще копираме файлове. Скриптът да копира файловете със съдържание, променено преди по-малко от 45 мин, от първата директория във втората директория. Ако втората директория не е подадена по име, нека да получи такова от днешната дата във формат, който ви е удобен. При желание новосъздадената директория да се архивира.

Ans:
if [ $# -eq 2 ];then
    find $1 -cmin -45 -type f -exec cp {} $2 \;
else
    dirname=$(date | tr -s ' ' | cut -d ' ' -f2,3,4 | sed 's/ /-/g')
    mkdir ~/$dirname
    find $1 -cmin -45 -type f -exec cp {} ~/$dirname \;
fi

exit 0

05-b-4500: Да се напише shell скрипт, който получава при стартиране като параметър в командния ред идентификатор на потребител. Скриптът периодично (sleep(1)) да проверява дали потребителят е log-нат, и ако да - да прекратява изпълнението си, извеждайки на стандартния изход подходящо съобщение.
NB! Можете да тествате по същият начин като в 05-b-4300.txt

Ans:
if [ $# -ne 1 ];then
    echo "Wrong number of arguments passed!"
    exit 1
fi

if ( who | grep -q "$1" );then
    echo "User is logged!"
else
    echo "User is not logged"
fi

exit 0

! who - логнати потребители

05-b-4600: Да се напише shell скрипт, който валидира дали дадено цяло число попада в целочислен интервал.
Скриптът приема 3 аргумента: числото, което трябва да се провери; лява граница на интервала; дясна граница на интервала.
Скриптът да връща exit status:
- 3, когато поне един от трите аргумента не е цяло число
- 2, когато границите на интервала са обърнати
- 1, когато числото не попада в интервала
- 0, когато числото попада в интервала

Примери:
$ ./validint.sh -42 0 102; echo $?
1

$ ./validint.sh 88 94 280; echo $?
1

$ ./validint.sh 32 42 0; echo $?
2

$ ./validint.sh asdf - 280; echo $?
3

Ans:
number=$1
left=$2
right=$3

for num in $@; do
        if echo $num | grep -q "[a-zA-Z]\+"; then
                exit 3
        fi
done

if [ ${number} -gt ${left} ] && [ ${number} -lt ${right} ]; then
        exit 0
elif [ ${right} -lt ${left} ]; then
        exit 2
elif [ ${number} -lt ${left} ] || [ ${number} -gt ${right} ]; then
        exit 1
fi

! $@ - аргументите, които сме подали

05-b-4700: Да се напише shell скрипт, който форматира големи числа, за да са по-лесни за четене.
Като пръв аргумент на скрипта се подава цяло число.
Като втори незадължителен аргумент се подава разделител. По подразбиране цифрите се разделят с празен интервал.

Примери:
$ ./nicenumber.sh 1889734853
1 889 734 853

$ ./nicenumber.sh 7632223 ,
7,632,223

Ans:
if !( echo $1 | grep -q "[0-9]\+$" );then
    echo "Wrong argument passed!"
    exit 1
fi

if [ $# -eq 1 ];then
    echo "$(echo $1 | rev | sed 's/\([0-9]\{3\}\)/\1 /g' | rev)"
elif [ $# -eq 2 ];then
    delim=$2
    echo $1 | rev | sed "s/\([0-9]\{3\}\)/\1$delim/g" | rev
else
    echo "Wrong number of arguments passed!"
    exit 2
fi

exit 0

05-b-4800: Да се напише shell скрипт, който приема файл и директория. Скриптът проверява в подадената директория и нейните под-директории дали съществува копие на подадения файл и отпечатва имената на намерените копия, ако съществуват такива.
NB! Под 'копие' разбираме файл със същото съдържание.

Ans:
if [ $# -ne 2 ] || [ ! -f $1 ] || [ ! -d $2 ];then
    echo "Wrong arguments passed!"
    exit 1
fi

while read line; do
    if cmp "$line" "$1"; then
        echo $line
    fi
done < <(find "$2" -type f)

! if [ "$(diff -q "$1" "$line" | wc -l)" -eq 0 ]; then ...
! cmp - compare byte by byte
! diff - compate line by line 

05-b-5500: Да се напише shell script, който генерира HTML таблица съдържаща описание на потребителите във виртуалката ви. Таблицата трябва да има:
- заглавен ред с имената нa колоните
- колони за username, group, login shell, GECOS field (https://en.wikipedia.org/wiki/Gecos_field)

Пример:
$ ./passwd-to-html.sh > table.html
$ cat table.html
<table>
  <tr>
    <th>Username</th>
    <th>group</th>
    <th>login shell</th>
    <th>GECOS</th>
  </tr>
  <tr>
    <td>root</td>
    <td>root</td>
    <td>/bin/bash</td>
    <td>GECOS here</td>
  </tr>
  <tr>
    <td>ubuntu</td>
    <td>ubuntu</td>
    <td>/bin/dash</td>
    <td>GECOS 2</td>
  </tr>
</table>

Ans:
echo "
<table>
  <tr>
    	<th>Username</th>
    	<th>group</th>
    	<th>login shell</th>
    	<th>GECOS</th>
  </tr>"

while read line; do
    username=$(echo $line | cut -d ':' -f1)
    group=$(echo $line | cut -d ':' -f4)
    shell=$(echo $line | cut -d ':' -f7)
    gecos=$(echo $line | grep -o "[[:alpha:]]\+ [[:alpha:]]\+")

    echo "<tr>
            <th>$username</th>
            <th>$group</th>
            <th>$shell</th>
            <th>$gecos</th>
        </tr>"
done < <(cat /etc/passwd 2>/dev/null)

echo "</table>"

! while read line; do
    awk -F ":" '{
        print "    <tr>";
        print "        <th>",$1,"</th>";
        print "        <th>",$4,"</th>";
        print "        <th>",$7,"</th>";
        print "        <th>",$5,"</th>";
        print "    </tr>";
    }' <<< "$line"
done < /etc/passwd

05-b-6600: Да се напише shell скрипт, който получава единствен аргумент директория и изтрива всички повтарящи се (по съдържание) файлове в дадената директория. Когато има няколко еднакви файла, да се остави само този, чието име е лексикографски преди имената на останалите дублирани файлове.

Примери:
$ ls .
f1 f2 f3 asdf asdf2
# asdf и asdf2 са еднакви по съдържание, но f1, f2, f3 са уникални

$ ./rmdup .
$ ls .
f1 f2 f3 asdf
# asdf2 е изтрит

Ans:
if [ $# -ne 1 ] || [ ! -d $1 ];then
    echo "Wrong arguments passed!"
    exit 1
fi

while read file1; do
    while read file2; do
        if [ -f "$file1" -a -f "$file2" -a ! "$file1" = "$file2" ]; then
            if cmp -s "$file1" "$file2"; then
                to_remove="$(echo -e "$file1\n$file2" | sort | tail -n 1)"
                if ! rm "$to_remove"; then
                    echo "There was a problem removing a file." >&2
                    exit 3
                fi
            fi
        fi
    done < <(find $1 -maxdepth 1 -type f | sort -d)
done < <(find $1 -maxdepth 1 -type f | sort -d)

Аns:
...
while read line; do
    while read file; do
        if [ "$file" = "$line" ];then
            continue
        fi
        if !(diff $file $line | grep -q "[a-zA-Z0-9]\+");then
            rm $line 2>/dev/null
        fi
    done < <(find $1 -maxdepth 1 -type f | sort -d)
done < <(find $1 -maxdepth 1 -type f | sort -d)

! echo -e -> enable interpretation of backslash escapes
! cmp -s -> silent (suppress all normal output) - дава само exit status-a 
! file1 = file2 -> понеже въртим вложени цикли избягваме случая да сравняваме един файл със себе си
= and == are for string comparisons
-eq is for numeric comparisons
-eq is in the same family as -lt, -le, -gt, -ge, and -ne
! -а -> and, така може да ползваме едни [], ако използваме && трябва да имаме [] && [] && ...

05-b-6800: Да се напише shell скрипт, който получава единствен аргумент директория и отпечатва списък с всички файлове и директории в нея (без скритите).
До името на всеки файл да седи размера му в байтове, а до името на всяка директория да седи броят на елементите в нея (общ брой на файловете и директориите, без скритите).

a) Добавете параметър -a, който указва на скрипта да проверява и скритите файлове и директории.

Пример:
$ ./list.sh .
asdf.txt (250 bytes)
Documents (15 entries)
empty (0 entries)
junk (1 entry)
karh-pishtov.txt (8995979 bytes)
scripts (10 entries)

Ans: 
if [ $# -eq 2 ] && [ "$2" = "-a" ]; then
	extra_opts=""
else
	extra_opts="-not -name .*"
fi

	while read line; do
		if (stat -c "%F" $line | grep -q "directory"); then
			echo "$line ($(find $line | wc -l) entries)"
		elif (stat -c "%F" $line | grep -q "regular"); then
			echo "$line ($(stat -c "%s" $line) bytes)"
		fi
	done< <(find $1 -maxdepth 1 ${extra_opts})

! stat -c -> за да подам printf
  %F - file type
  %s - total size in bytes
! private files - започват с .

05-b-7000: Да се напише shell скрипт, който приема произволен брой аргументи - имена на файлове. Скриптът да прочита от стандартния вход символен низ и за всеки от зададените файлове извежда по подходящ начин на стандартния изход броя на редовете, които съдържат низа.
NB! Низът може да съдържа интервал.

Ans:
read
reply=$REPLY

counter=0

for file in $@; do
	if [ ! -f $file ]; then
		continue
	fi

	lines=$(cat $file | grep "${reply}" | wc -l)
	echo "File $file contains $lines with $1"
	counter=$(( counter + lines ))
done

echo "The string is contained in: $counter lines"

05-b-7100: Да се напише shell скрипт, който приема два параметъра - име на директория и число. Скриптът да извежда на стандартния изход имената на всички обикновени файлове във директорията, които имат размер, по-голям от подаденото число.

Ans:
#!/bin/bash

if [ $# -ne 2 ] || [ ! -d $1 ] || !( echo $2 | grep -q "[[:digit:]]\+"); then
    echo "Wrong arguments passed!"
    exit 1
fi

find $1 -type f -size +$2c

! "+2c" specifies that the size of the files should be greater than 2 bytes. The "c" indicates that the size is in bytes, as opposed to other units like kilobytes (k) or megabytes (M).

05-b-7200: Да се напише shell скрипт, който приема произволен брой аргументи - имена на файлове или директории. Скриптът да извежда за всеки аргумент подходящо съобщение:
	- дали е файл, който може да прочетем
	- ако е директория - имената на файловете в нея, които имат размер, по-малък от броя на файловете в директорията.

Ans: 
#!/bin/bash

for arg in $@
do
    if (stat -c "%F" $arg | grep -q  "regular file"); then
        if [ -r $arg ]; then
            echo "The file is readable"
        else
            echo "The file is NOT readable"
        fi
    elif ( stat -c "%F" $arg | grep -q "directory"); then
        size=$(find $arg -type f | wc -l)
        find $arg -type f -size -$size
    fi
done

! -r -> readable (-w, -x)
! ако искам по-голям размер от дадения +$size

05-b-7500: Напишете shell script guess, която си намисля число, което вие трябва да познаeте. В зависимост от вашия отговор, програмата трябва да ви казва "надолу" или "нагоре", докато не познате числото. Когато го познаете, програмата да ви казва с колко опита сте успели.

./guess (програмата си намисля 5)

Guess? 22
...smaller!
Guess? 1
...bigger!
Guess? 4
...bigger!
Guess? 6
...smaller!
Guess? 5
RIGHT! Guessed 5 in 5 tries!

Hint: Един начин да направите рандъм число е с $(( (RANDOM % b) + a  )), което ще генерира число в интервала [a, b]. Може да вземете a и b като параметри, но не забравяйте да направите проверката.

Ans:
#!/bin/bash

num=$(( (RANDOM % 100) + 0 ))

while true
do
    echo "Guess? "
    read
    if [ $REPLY -lt $num ]; then
        echo "...smaller!"
    elif [ $REPLY -gt $num ]; then
        echo "...bigger!"
    else
        echo "Right! Guessed $num in $counter"
        exit 0
    fi
done

05-b-7550: Да се напише shell скрипт, който приема параметър - име на потребител. Скриптът да прекратява изпълненито на всички текущо работещи процеси на дадения потребител, и да извежда колко са били те.
NB! Може да тествате по същият начин като описаният в 05-b-4300

Ans:
#!/bin/bash

if [ $# -ne 1 ];then
    echo "Wrong number of arguments passed"
fi

echo "The number of processes are: $(ps -u "$1" | tail -n +2 | wc -l)"

while read pid
do
    #kill $pid
done < <(ps -u "$1" -o pid=)

! ps -u username
! kill pid

05-b-7700: Да се напише shell скрипт, който приема два параметъра - име на директория и число. Скриптът да извежда сумата от размерите на файловете в директорията, които имат размер, по-голям от подаденото число.

Ans:
counter=0

while read line; do
	size=$(cat $line | cut -d ' ' -f1)
	counter=$(( counter + size))
done < <(find $1 -type f -size +$2c -printf "%s %p\n")

echo "The sum of the sizes is: $counter"

05-b-7800: Да се напише shell скрипт, който намира броя на изпълнимите файлове в PATH.
Hint: Предполага се, че няма спейсове в имената на директориите
Hint2: Ако все пак искаме да се справим с този случай, да се разгледа IFS променливата и констуркцията while read -d

Ans:
#!/bin/bash

if [ $# -ne 1 ] && [ ! -d $1 ];then
    echo "Wrong argument passed!"
    exit 1
fi

sum=0
IFS=":"
while read -d: dir; do
	count=$(find "$dir" -maxdepth 1 -type f -executable | wc -l) 
	sum=$(( sum + count))
done <<< "$PATH"

! -readable / -writable / -executable OR -perm /444
! read -d конструкцията разделя директориите по нов ред
  IFS=":" .... while read -d: dir; do ....

05-b-8000: Напишете shell script, който получава като единствен аргумент име на потребител и за всеки негов процес изписва съобщение за съотношението на RSS към VSZ. Съобщенията да са сортирани, като процесите с най-много заета виртуална памет са най-отгоре.

Hint:
Понеже в Bash няма аритметика с плаваща запетая, за смятането на съотношението използвайте командата bc. За да сметнем нампример 24/7, можем да: echo "scale=2; 24/7" | bc
Резултатът е 3.42 и има 2 знака след десетичната точка, защото scale=2.
Алтернативно, при липса на bc ползвайте awk.

Ans:
#!/bin/bash

if !(cat /etc/passwd | grep -q "$1"); then
    echo "Wrong argument passed!"
    exit 1
fi

ps -u $1 -o rss=,vsz=,pid= | awk '{print $3,$1/$2}' | sort -k1r

!   while read -r pid rss vsz cmd; do
    	ratio=$(echo "scale=2; $rss/$vsz" | bc)
    	echo "Process $pid ($cmd) RSS/VSZ ratio: $ratio"
    done < <(....)

! bc -> basic calculator

05-b-9100: Опишете поредица от команди или напишете shell скрипт, които/който при известни две директории SOURCE и DESTINATION:
- намира уникалните "разширения" на всички файлове, намиращи се някъде под SOURCE. (За простота приемаме, че в имената на файловете може да се среща символът точка '.' максимум веднъж.)
- за всяко "разширение" създава по една поддиректория на DESTINATION със същото име
- разпределя спрямо "разширението" всички файлове от SOURCE в съответните поддиректории в DESTINATION

Ans:
if [ $# -ne 2 ] || [ ! -d $1 ] || [ ! -d $2 ];then
    echo "Wrong arguments passed!"
    exit 1
fi

while read line
do
    mkdir $2/$line
    find $1 -type f | grep "$line$" | xargs -I {} cp {} $2/$line
done < <(find $1 -type f | grep -o "\.[[:alpha:]]\+$" | sort -d | uniq)

05-b-9200: Да се напише shell скрипт, който получава произволен брой аргументи файлове, които изтрива.
Ако бъде подадена празна директория, тя бива изтрита. Ако подадения файл е директория с поне 1 файл, тя не се изтрива.
За всеки изтрит файл (директория) скриптът добавя ред във log файл с подходящо съобщение.

а) Името на log файла да се чете от shell environment променлива, която сте конфигурирали във вашия .bashrc.
б) Добавете параметър -r на скрипта, който позволява да се изтриват непразни директории рекурсивно.
в) Добавете timestamp на log съобщенията във формата: 2018-05-01 22:51:36

Примери:
$ export RMLOG_FILE=~/logs/remove.log
$ ./rmlog -r f1 f2 f3 mydir/ emptydir/
$ cat $RMLOG_FILE
[2018-04-01 13:12:00] Removed file f1
[2018-04-01 13:12:00] Removed file f2
[2018-04-01 13:12:00] Removed file f3
[2018-04-01 13:12:00] Removed directory recursively mydir/
[2018-04-01 13:12:00] Removed directory emptydir/

Ans:
for argv in $@
do
    if [ -f $argv ]; then
        rm $argv
        echo "[ $(date | tr -s ' ' | cut -d ' ' -f2,3,4 | sed 's/\([[:alpha:]]\+\) \([[:digit:]]\+\)/\1-\2/g') ] Removed file $argv" >> ~/log

    elif [ -d $argv ]; then
        if (find $argv | grep -q "[[:print:]]\+"); then
           rm -r $argv
           echo "[ $(date | tr -s ' ' | cut -d ' ' -f2,3,4 | sed 's/\([[:alpha:]]\+\) \([[:digit:]]\+\)/\1-\2/g') ] Removed directory recursivly $argv" >> ~/log
        else
           rm $argv
           echo "[ $(date | tr -s ' ' | cut -d ' ' -f2,3,4 | sed 's/\([[:alpha:]]\+\) \([[:digit:]]\+\)/\1-\2/g'') ] Removed directory $argv" >> ~/log
        fi
    fi
done

! rm -r -> recursively remove in directory 

05-b-9500: (Цветно принтиране) Напишете shell script color_print, който взима два параметъра.
Първият може да е измежду "-r", "-g" "-b", а вторият е произволен string.
На командата "echo" може да се подаде код на цвят, който ще оцвети текста в определения цвят.
В зависимост от първия аргумент, изпринтете втория аргумен в определения цвят:
"-r" е червено. Кодът на червеното е '\033[0;31m' (echo -e "\033[0;31m This is red")
"-g" е зелено. Кодът на зеленото е '\033[0;32m' (echo -e "\033[0;32m This is green")
"-b" е синьо. Кодът на синьото е '\033[0;34m' (echo -e "\033[0;34m This is blue")
Ако е подадена друга буква изпишете "Unknown colour", а ако изобщо не е подаден аргумент за цвят, просто изпишете текста.
Hint:
В края на скрипта си напишете:
echo '\033[0m',за да не се прецакат цветовете на терминала. Това е цветът на "няма цвят".

Ans: 
if [ $# -eq 1 ]; then
    echo $1
    exit 0
elif [ $# -eq 2 ] && ( echo $1 | grep -q "\-[grb]"); then
    if [ "$1" = "-r" ]; then
        echo -e "\033[0;31m $2"
    elif [ "$2" = "-g" ]; then
        echo -e "\033[0;32m $2"
    else
        echo -e "\033[0;34m $2"
    fi
else
    echo "Unknown colour"
    exit 1
fi

echo '\033[0m'

! echo -e ->  позволява интерпретация на escape-символи

05-b-9501: Този път програмата ви ще приема само един параметър, който е измежду ("-r", "-b", "-g", "-x").
Напишете shell script, който приема редовете от stdin и ги изпринтва всеки ред с редуващ се цвят. Цветовете вървят RED-GREEN-BLUE и цветът на първия ред се определя от аргумента.
Ако е подаден аргумент "-x", то не трябва да променяте цветовете в терминала (т.е., все едно сте извикали командата cat).
Hint: Не забравяйте да връщате цветовете в терминала.

Ans:
if [ $# -eq 1 ] && (echo $1 | grep -q "\-[rbgx]");then
    if [ "$1" = "-x" ];then
        while read
        do
            echo "$REPLY"
        done
    else
        counter=1
        border=3
        while read
        do
            if [ $counter -eq 1 ];then
                echo -e "\033[0;31m $REPLY"
            elif [ $counter -eq 2 ];then
                echo -e "\033[0;32m $REPLY"
            elif [ $counter -eq 3 ];then
                echo -e "\033[0;34m $REPLY"
            fi
            counter=$((counter + 1))
            if [ $counter -gt $border ];then
                counter=1
            fi
        done
    fi
fi

echo '\033[0m'

05-b-9600: Да се напише shell скрипт, който получава произволен брой аргументи файлове, които изтрива.
Ако бъде подадена празна директория, тя бива изтрита. Ако подадения файл е директория с поне 1 файл, тя не се изтрива.

Да се дефинира променлива BACKUP_DIR (или друго име), в която:
- изтритите файлове се компресират и запазват
- изтритите директории се архивират, комприсират и запазват
- имената на файловете е "filename_yyyy-mm-dd-HH-MM-SS.{gz,tgz}", където filename е оригиналното име на файла (директорията) преди да бъде изтрит

а) Добавете параметър -r на скрипта, който позволява да се изтриват непразни директории рекурсивно и съответно да се запазят в BACKUP_DIR

Примери:
$ export BACKUP_DIR=~/.backup/
# full-dir/ има файлове и не може да бъде изтрита без параметър -r
$ ./trash f1 f2 full-dir/ empty-dir/
error: full-dir/ is not empty, will not detele
$ ls $BACKUP_DIR
f1_2018-05-07-18-04-36.gz
f2_2018-05-07-18-04-36.gz
empty-dir_2018-05-07-18-04-36.tgz

$ ./trash -r full-dir/
$ ls $BACKUP_DIR
f1_2018-05-07-18-04-36.gz
f2_2018-05-07-18-04-36.gz
full-dir_2018-05-07-18-04-50.tgz
empty-dir_2018-05-07-18-04-36.tgz

# можем да имаме няколко изтрити файла, които се казват по един и същ начин
$ ./trash somedir/f1
$ ls $BACKUP_DIR
f1_2018-05-07-18-04-36.gz
f1_2018-05-07-18-06-01.gz
f2_2018-05-07-18-04-36.gz
full-dir_2018-05-07-18-04-50.tgz
empty-dir_2018-05-07-18-04-36.tgz

Ans:
BACKUP_DIR="~/dir"

# Функция за компресиране и архивиране на файл/директория
backup() {
    # Извличане на името на файла/директорията и определяне на формата за дата и час
    local filename=$(basename "$1")
    local date=$(date +"%Y-%m-%d-%H-%M-%S")

    # Проверка дали е директория и архивиране, ако има поне 1 файл в нея
    if [[ -d "$1" ]] && [[ $(find "$1" -type f | wc -l) -gt 0 ]]; then
        tar czf "$BACKUP_DIR/$filename"_"$date.tgz" "$1"
    else
        # Иначе е файл и компресиране
        gzip -c "$1" > "$BACKUP_DIR/$filename"_"$date.gz"
    fi
}

# Изтриване на всеки файл/директория, като преди това се прави бекъп
for file in "$@"; do
    if [[ -d "$file" ]]; then
        if [[ $(find "$file" -type f | wc -l) -gt 0 ]]; then
            echo "Skipping directory $file (contains files)"
            continue
        fi
    fi

    echo "Deleting $file"
    backup "$file"
    rm -r "$file"
done

Ans:
#! /bin/bash

if [ $# -ge 1 -a "$1" = "-r" ]; then
    recursive=true
    shift
fi

export BACKUP_DIR=~/.backup/

while [ $# -gt 0 ]; do
    if [ -f "$1" ]; then 
        if ! (gzip "$1" && mv "${1}.gz" "$BACKUP_DIR/${1}_$(date '+%F-%H-%M-%S').gz"); then
            echo "There was a problem compressing and moving $1." >&2
            exit 1
        fi
        echo "[$(date '+%F %T')] Compressed and removed file: $1"
    elif [ -d "$1" ]; then
        number_of_files="$(find "$1" -type f | wc -l)"
        if [ "$number_of_files" -eq 0 ]; then
            if ! (tar czf "${1}.tgz" "$1" && mv "${1}.tgz" "$BACKUP_DIR/${1}_$(date '+%F-%H-%M-%S').tgz" && rm -r "$1"); then
               echo "There was a problem compresing and moving $1" >&2
               exit 3
            fi
            echo "[$(date '+%F %T')] Compressed and moved directory with no files: $1" 
        else
            if [ "$recursive" ]; then
                if ! (tar czf "${1}.tgz" "$1" && mv "${1}.tgz" "$BACKUP_DIR/${1}_$(date '+%F-%H-%M-%S').tgz" && rm -r "$1"); then
                    "There was a problem compressing and moving recursicely $1.">&2
                    exit 2
                fi
                echo "[$(date '+%F %T')] Compressed and moved directory recursively: $1"
            fi
        fi
    fi

    shift
done


! local -> дефиниране на променливи, които са локални за текущата функция или скрипт и не могат да бъдат достъпни извън нея
! tar [options] [archive-file] [file or directory to be archived]
Options: 
-c : Creates Archive 
-x : Extract the archive 
-f : creates archive with given filename 
-v : Displays Verbose Information
-z : zip, tells tar command that creates tar file using gzip 
! Gzip reduces the size of the named files
-c --stdout --to-stdout
Write output on standard output; keep original files unchanged. 
-d --decompress 
-f --force

05-b-9601: Да се напише shell скрипт, който възстановява изтрити файлове, които имат запазено копие в BACKUP_DIR (от предната задача).
При възстановяването файловете да се декомпресират, а директориите да се декомпресират и разархивират.

а) Да се дефинира параметър -l, който изрежда всички файлове, които могат да бъдат възстановени и датата на тяхното изтриване.

б) Скриптът да приема 2 параметъра. Първият е името на файла, който да се възстанови, а вторията е директорията, в която файлът да бъде възстановен. Ако вторият аргумент липсва, файлът да се възстановява в сегашната директория, където скриптът се изпълнява.

в) Когато има N > 1 запазени файла със същото име, да се изпише списък с N реда на потребителя и да се изиска той да въведе цяло число от 1 до N, за да избере кой файл да възстанови.

Примери:
# BACKUP_DIR трябва да е дефинирана преди използването на скрипта
$ echo $BACKUP_DIR
~/.backup

$ ./restore.sh -l
f1  (2018/05/07 18:04:36)
f1  (2018/05/07 18:06:01)
f2  (2018/05/07 18:04:36)
full-dir    (2018/05/07 18:04:50)
empty-dir   (2018/05/07 18:04:36)

$ ls restored-dir/
# възстановяване на файл в подадена директория
$ ./restore.sh f2 target-dir/
$ ls restored-dir/
f2

# възстановяване на дублиран файл в сегашната директория
$ ./restore.sh f1
(1) f1  (2018/05/07 18:04:36)
(2) f1  (2018/05/07 18:06:01)
choose file (1, 2):
# потребителят въвежда 2

$ ls
f1

$ ./restore.sh -l
f1  (2018/05/07 18:04:36)
full-dir    (2018/05/07 18:04:50)
empty-dir   (2018/05/07 18:04:36)

# възстановяване на директория в сегашната директория
$ ./restore.sh full-dir
$ ls
f1  full-dir/

Ans: ---

